using R2API.ItemDrop;
using RoR2;
using System.Collections.Generic;
using System.Linq;

namespace R2API {

    namespace ItemDropAPITools {

        public class DropList {
            /*
                The purpose of this class is to store the original drop lists for a run and to generate and store the master drop lists for a run.
                As well as changing and reverting the drop lists during a run.
                Instead of drop lists being created from scratch, the master drop lists are generated by modifying a vanilla drop list.
                Therefore items can be added to or removed from the original list.

                This is why I wanted a way to remove an item from both the add and remove lists, so the original behavior could be restored,
                    without first having to calculated whether an item would originally be apart the drop list.
                Becuse otherwise to restore original behavior, if the item was originally apart of the drop list, adding it to the add drop list,
                    would not change the master drop list.
                If it was not originally part of the drop list, adding it to the remove drop list would not change the master drop list.
                But you would have to know what it was going to do oringally to restore its original behavior.
                Being able to remove the item from either list I thought would be the easier way to restore original behavior, but I was told having a function for this was confusing.

                Side Note:
                The original lists are saved because they are known good lists that will work in every possible scenario.
                Many interactables that drop items will filter the drop list to create their subsets of items.
                They will then select one item from each subset.
                Before finally determining which item to drop.
                Because of this, even if a subset has zero odds being selected, it still must be a list from which a valid item can be selected.
                The odds for selecteting which subset is picked will have already been updated, but these known good lists are substituted in so an item may be selected without raising errors.
                Xoroshiro128Plus.NextElementUniform chooses the item from each subset. If there was some way to prevent it from throwing errors when it is given an empty list then this wouldn't be necessary.
                I was told that because this method is a generic method it would be difficult to change with IL. I couldn't figure it out, so this is my solution.

                Some of the classes where this was the case may have ben updated so this may longer be required everywhere it occurs in this project.
            */

            public static bool OriginalListsSaved;
            public static List<PickupIndex> Tier1DropListOriginal = new List<PickupIndex>();
            public static List<PickupIndex> Tier2DropListOriginal = new List<PickupIndex>();
            public static List<PickupIndex> Tier3DropListOriginal = new List<PickupIndex>();
            public static List<PickupIndex> BossDropListOriginal = new List<PickupIndex>();
            public static List<PickupIndex> LunarDropListOriginal = new List<PickupIndex>();
            public static List<PickupIndex> EquipmentDropListOriginal = new List<PickupIndex>();
            public static List<PickupIndex> NormalEquipmentDropListOriginal = new List<PickupIndex>();
            public static List<PickupIndex> LunarEquipmentDropListOriginal = new List<PickupIndex>();
            public static List<PickupIndex> SpecialItemsOriginal = new List<PickupIndex>();
            public static List<PickupIndex> SpecialEquipmentOriginal = new List<PickupIndex>();

            private static List<PickupIndex> Tier1DropListBackup = new List<PickupIndex>();
            private static List<PickupIndex> Tier2DropListBackup = new List<PickupIndex>();
            private static List<PickupIndex> Tier3DropListBackup = new List<PickupIndex>();
            private static List<PickupIndex> EquipmentDropListBackup = new List<PickupIndex>();

            public List<PickupIndex> AvailableTier1DropList = new List<PickupIndex>();
            public List<PickupIndex> AvailableTier2DropList = new List<PickupIndex>();
            public List<PickupIndex> AvailableTier3DropList = new List<PickupIndex>();
            public List<PickupIndex> AvailableBossDropList = new List<PickupIndex>();
            public List<PickupIndex> AvailableLunarDropList = new List<PickupIndex>();
            public List<PickupIndex> AvailableEquipmentDropList = new List<PickupIndex>();
            public List<PickupIndex> AvailableNormalEquipmentDropList = new List<PickupIndex>();
            public List<PickupIndex> AvailableLunarEquipmentDropList = new List<PickupIndex>();
            public List<PickupIndex> AvailableSpecialItems = new List<PickupIndex>();
            public List<PickupIndex> AvailableSpecialEquipment = new List<PickupIndex>();

            public const string NullIconTextureName = "texNullIcon";

            public List<PickupIndex> GetDropList(ItemTier itemTier) {
                if (itemTier == ItemTier.Tier1) {
                    return AvailableTier1DropList;
                }
                else if (itemTier == ItemTier.Tier2) {
                    return AvailableTier2DropList;
                }
                else if (itemTier == ItemTier.Tier3) {
                    return AvailableTier3DropList;
                }
                else if (itemTier == ItemTier.Boss) {
                    return AvailableBossDropList;
                }
                else if (itemTier == ItemTier.Lunar) {
                    return AvailableLunarDropList;
                }
                else {
                    return AvailableNormalEquipmentDropList;
                }
            }

            /*
                Creates a new list containing all the items in another list.
                Returns a list containing none when given an empty list to fix a bug caused by having a list with a length of zero.
            */
            private static List<PickupIndex> BackupDropList(IEnumerable<PickupIndex> list) {
                var pickupIndices = list.ToList();
                return pickupIndices.Any() ? pickupIndices.ToList() : new List<PickupIndex> { PickupIndex.none };
            }

            /*
                This will backup the four main drop lists in Run and then overwrite them.
                The intention is this function is used when changing the drop lists only temporarily.
            */
            public static void SetDropLists(IEnumerable<PickupIndex> givenTier1, IEnumerable<PickupIndex> givenTier2,
                IEnumerable<PickupIndex> givenTier3, IEnumerable<PickupIndex> givenEquipment) {
                var availableItems = new List<List<PickupIndex>> {
                    BackupDropList(givenTier1),
                    BackupDropList(givenTier2),
                    BackupDropList(givenTier3),
                    BackupDropList(givenEquipment)
                };

                var run = Run.instance;
                Tier1DropListBackup = BackupDropList(run.availableTier1DropList);
                Tier2DropListBackup = BackupDropList(run.availableTier2DropList);
                Tier3DropListBackup = BackupDropList(run.availableTier3DropList);
                EquipmentDropListBackup = BackupDropList(run.availableEquipmentDropList);

                run.availableTier1DropList = availableItems[0];
                run.availableTier2DropList = availableItems[1];
                run.availableTier3DropList = availableItems[2];
                run.availableEquipmentDropList = availableItems[3];
            }

            //  This function will revert the four main drop lists in Run to how they were before they were changed temporarily.
            public static void RevertDropLists() {
                var oldItems = new List<List<PickupIndex>> {
                    BackupDropList(Tier1DropListBackup),
                    BackupDropList(Tier2DropListBackup),
                    BackupDropList(Tier3DropListBackup),
                    BackupDropList(EquipmentDropListBackup)
                };

                var run = Run.instance;
                run.availableTier1DropList = oldItems[0];
                run.availableTier2DropList = oldItems[1];
                run.availableTier3DropList = oldItems[2];
                run.availableEquipmentDropList = oldItems[3];
            }

            //  Clears all the drop lists in the Run class.
            public void ClearAllLists(Run run) {
                run.availableItems.Clear();
                run.availableEquipment.Clear();
                run.availableTier1DropList.Clear();
                run.availableTier2DropList.Clear();
                run.availableTier3DropList.Clear();
                run.availableBossDropList.Clear();
                run.availableLunarDropList.Clear();
                run.availableEquipmentDropList.Clear();
                run.availableNormalEquipmentDropList.Clear();
                run.availableLunarEquipmentDropList.Clear();
            }

            //  Backs up all the original drop lists generated for this run.
            public void DuplicateDropLists(Run run) {
                if (!OriginalListsSaved) {
                    Tier1DropListOriginal = BackupDropList(run.availableTier1DropList);
                    Tier2DropListOriginal = BackupDropList(run.availableTier2DropList);
                    Tier3DropListOriginal = BackupDropList(run.availableTier3DropList);
                    LunarDropListOriginal = BackupDropList(run.availableLunarDropList);
                    EquipmentDropListOriginal = BackupDropList(run.availableEquipmentDropList);
                    NormalEquipmentDropListOriginal = BackupDropList(run.availableNormalEquipmentDropList);
                    LunarEquipmentDropListOriginal = BackupDropList(run.availableLunarEquipmentDropList);

                    BossDropListOriginal = BackupDropList(run.availableBossDropList);

                    /*
                    foreach (var bossItem in Catalog.SpecialItems) {
                        var pickupIndex = PickupCatalog.FindPickupIndex(bossItem);
                        if (!BossDropListOriginal.Contains(pickupIndex)) {
                            BossDropListOriginal.Add(pickupIndex);
                        }
                    }
                    */

                    SpecialItemsOriginal.Clear();
                    foreach (var itemIndex in Catalog.SpecialItems) {
                        if (run.availableItems.Contains(itemIndex)) {
                            SpecialItemsOriginal.Add(PickupCatalog.FindPickupIndex(itemIndex));
                        }
                    }
                    foreach (var itemIndex in Catalog.ScrapItems.Values) {
                        if (run.availableItems.Contains(itemIndex)) {
                            SpecialItemsOriginal.Add(PickupCatalog.FindPickupIndex(itemIndex));
                        }
                    }
                    
                    SpecialEquipmentOriginal.Clear();
                    foreach (var equipmentIndex in Catalog.EliteEquipment) {
                        var sprite = EquipmentCatalog.GetEquipmentDef(equipmentIndex).pickupIconSprite;
                        if (sprite != null && !sprite.name.Contains(NullIconTextureName)) {
                            SpecialEquipmentOriginal.Add(PickupCatalog.FindPickupIndex(equipmentIndex));
                        }
                    }

                    OriginalListsSaved = true;
                }
            }

            //  Saves the adjusted drop lists, which are the master lists.
            internal void GenerateDropLists(
                Dictionary<ItemTier, List<ItemIndex>> itemsToAdd,
                Dictionary<ItemTier, List<ItemIndex>> itemsToRemove,
                Dictionary<EquipmentDropType, List<EquipmentIndex>> equipmentsToAdd,
                Dictionary<EquipmentDropType, List<EquipmentIndex>> equipmentsToRemove) {

                AvailableTier1DropList = BackupDropList(CreateDropList(Tier1DropListOriginal, itemsToAdd[ItemTier.Tier1], itemsToRemove[ItemTier.Tier1]));
                AvailableTier2DropList = BackupDropList(CreateDropList(Tier2DropListOriginal, itemsToAdd[ItemTier.Tier2], itemsToRemove[ItemTier.Tier2]));
                AvailableTier3DropList = BackupDropList(CreateDropList(Tier3DropListOriginal, itemsToAdd[ItemTier.Tier3], itemsToRemove[ItemTier.Tier3]));
                AvailableLunarDropList = BackupDropList(CreateDropList(LunarDropListOriginal, itemsToAdd[ItemTier.Lunar], itemsToRemove[ItemTier.Lunar]));
                AvailableSpecialItems = BackupDropList(CreateDropList(SpecialItemsOriginal, itemsToAdd[ItemTier.NoTier], itemsToRemove[ItemTier.NoTier]));

                AvailableEquipmentDropList = BackupDropList(CreateDropList(NormalEquipmentDropListOriginal,
                    equipmentsToAdd[EquipmentDropType.Normal], equipmentsToRemove[EquipmentDropType.Normal]));
                AvailableNormalEquipmentDropList = AvailableEquipmentDropList;

                AvailableLunarEquipmentDropList = BackupDropList(CreateDropList(LunarEquipmentDropListOriginal,
                    equipmentsToAdd[EquipmentDropType.Lunar], equipmentsToRemove[EquipmentDropType.Lunar]));

                AvailableSpecialEquipment = BackupDropList(CreateDropList(SpecialEquipmentOriginal,
                    equipmentsToAdd[EquipmentDropType.Elite], equipmentsToRemove[EquipmentDropType.Elite]));

                AvailableBossDropList = BackupDropList(CreateDropList(BossDropListOriginal,
                    itemsToAdd[ItemTier.Boss], equipmentsToAdd[EquipmentDropType.Boss],
                    itemsToRemove[ItemTier.Boss], equipmentsToRemove[EquipmentDropType.Boss]));
            }

            //  This will apply all the add and remove alterations to an original drop list.
            private static List<PickupIndex> CreateDropList(IEnumerable<PickupIndex> vanillaDropList,
                IEnumerable<ItemIndex> itemsToAdd,
                IEnumerable<EquipmentIndex> equipmentsToAdd,
                IEnumerable<ItemIndex> itemsToRemove,
                IEnumerable<EquipmentIndex> equipmentsToRemove) {

                var finalDropList = new List<PickupIndex>();
                foreach (var pickupIndex in vanillaDropList) {
                    if (!finalDropList.Contains(pickupIndex)) {
                        finalDropList.Add(pickupIndex);
                    }
                }

                foreach (var itemIndex in itemsToAdd) {
                    var pickupIndex = PickupCatalog.FindPickupIndex(itemIndex);
                    if (!finalDropList.Contains(pickupIndex)) {
                        finalDropList.Add(pickupIndex);
                    }
                }

                foreach (var itemIndex in itemsToRemove) {
                    var pickupIndex = PickupCatalog.FindPickupIndex(itemIndex);
                    if (finalDropList.Contains(pickupIndex)) {
                        finalDropList.Remove(pickupIndex);
                    }
                }

                foreach (var equipmentIndex in equipmentsToAdd) {
                    var pickupIndex = PickupCatalog.FindPickupIndex(equipmentIndex);
                    if (!finalDropList.Contains(pickupIndex)) {
                        finalDropList.Add(pickupIndex);
                    }
                }

                foreach (var equipmentIndex in equipmentsToRemove) {
                    var pickupIndex = PickupCatalog.FindPickupIndex(equipmentIndex);
                    if (finalDropList.Contains(pickupIndex)) {
                        finalDropList.Remove(pickupIndex);
                    }
                }

                return finalDropList;
            }

            //  This will apply all the add and remove alterations to an original item drop list.
            private static List<PickupIndex> CreateDropList(
                IEnumerable<PickupIndex> vanillaDropList,
                IEnumerable<ItemIndex> itemsToAdd,
                IEnumerable<ItemIndex> itemsToRemove) {
                var finalDropList = new List<PickupIndex>();
                foreach (var pickupIndex in vanillaDropList) {
                    if (!finalDropList.Contains(pickupIndex)) {
                        finalDropList.Add(pickupIndex);
                    }
                }

                foreach (var itemIndex in itemsToAdd) {
                    var pickupIndex = PickupCatalog.FindPickupIndex(itemIndex);
                    if (!finalDropList.Contains(pickupIndex)) {
                        finalDropList.Add(pickupIndex);
                    }
                }

                foreach (var itemIndex in itemsToRemove) {
                    var pickupIndex = PickupCatalog.FindPickupIndex(itemIndex);
                    if (finalDropList.Contains(pickupIndex)) {
                        finalDropList.Remove(pickupIndex);
                    }
                }

                return finalDropList;
            }

            //  This will apply all the add and remove alterations to an original equipment drop list.
            private static List<PickupIndex> CreateDropList(
                IEnumerable<PickupIndex> vanillaDropList,
                IEnumerable<EquipmentIndex> equipmentsToAdd,
                IEnumerable<EquipmentIndex> equipmentsToRemove) {
                var finalDropList = new List<PickupIndex>();
                foreach (var pickupIndex in vanillaDropList) {
                    if (!finalDropList.Contains(pickupIndex)) {
                        finalDropList.Add(pickupIndex);
                    }
                }

                foreach (var equipmentIndex in equipmentsToAdd) {
                    var pickupIndex = PickupCatalog.FindPickupIndex(equipmentIndex);
                    if (!finalDropList.Contains(pickupIndex)) {
                        finalDropList.Add(pickupIndex);
                    }
                }

                foreach (var equipmentIndex in equipmentsToRemove) {
                    var pickupIndex = PickupCatalog.FindPickupIndex(equipmentIndex);
                    if (finalDropList.Contains(pickupIndex)) {
                        finalDropList.Remove(pickupIndex);
                    }
                }

                return finalDropList;
            }

            //  Sets the drop lists in Run using the adjusted, master lists.
            public void SetItems(Run run) {
                if (IsValidList(AvailableTier1DropList)) {
                    foreach (var pickupIndex in AvailableTier1DropList) {
                        run.availableTier1DropList.Add(pickupIndex);
                        run.availableItems.Add(PickupCatalog.GetPickupDef(pickupIndex).itemIndex);
                    }
                }

                if (IsValidList(AvailableTier2DropList)) {
                    foreach (var pickupIndex in AvailableTier2DropList) {
                        run.availableTier2DropList.Add(pickupIndex);
                        run.availableItems.Add(PickupCatalog.GetPickupDef(pickupIndex).itemIndex);
                    }
                }

                if (IsValidList(AvailableTier3DropList)) {
                    foreach (var pickupIndex in AvailableTier3DropList) {
                        run.availableTier3DropList.Add(pickupIndex);
                        run.availableItems.Add(PickupCatalog.GetPickupDef(pickupIndex).itemIndex);
                    }
                }

                if (IsValidList(AvailableBossDropList)) {
                    foreach (var pickupIndex in AvailableBossDropList) {
                        run.availableBossDropList.Add(pickupIndex);
                        run.availableItems.Add(PickupCatalog.GetPickupDef(pickupIndex).itemIndex);
                    }
                }

                if (IsValidList(AvailableLunarDropList)) {
                    foreach (var pickupIndex in AvailableLunarDropList) {
                        run.availableLunarDropList.Add(pickupIndex);
                        run.availableItems.Add(PickupCatalog.GetPickupDef(pickupIndex).itemIndex);
                    }
                }

                if (IsValidList(AvailableSpecialItems)) {
                    foreach (var pickupIndex in AvailableSpecialItems) {
                        run.availableItems.Add(PickupCatalog.GetPickupDef(pickupIndex).itemIndex);
                    }
                }

                if (IsValidList(AvailableEquipmentDropList)) {
                    foreach (var pickupIndex in AvailableEquipmentDropList) {
                        run.availableEquipmentDropList.Add(pickupIndex);
                        run.availableEquipment.Add(PickupCatalog.GetPickupDef(pickupIndex).equipmentIndex);
                    }
                }
                // high probability of code smell from ror2 code
                run.availableNormalEquipmentDropList = run.availableEquipmentDropList;

                if (IsValidList(AvailableLunarEquipmentDropList)) {
                    foreach (var pickupIndex in AvailableLunarEquipmentDropList) {
                        run.availableLunarEquipmentDropList.Add(pickupIndex);
                        run.availableEquipment.Add(PickupCatalog.GetPickupDef(pickupIndex).equipmentIndex);
                    }
                }

                if (IsValidList(AvailableSpecialEquipment)) {
                    foreach (var pickupIndex in AvailableSpecialEquipment) {
                        run.availableEquipment.Add(PickupCatalog.GetPickupDef(pickupIndex).equipmentIndex);
                    }
                }
            }

            public static List<PickupIndex> ToPickupIndices(IEnumerable<ItemIndex> indices) {
                return indices.Select(PickupCatalog.FindPickupIndex).ToList();
            }

            public static List<PickupIndex> ToPickupIndices(IEnumerable<EquipmentIndex> indices) {
                return indices.Select(PickupCatalog.FindPickupIndex).ToList();
            }

            //  Checks if a subset list has a valid population.
            public static bool IsValidList(IEnumerable<PickupIndex> dropList) {
                if (dropList.Count() == 0 || (dropList.Count() == 1 && dropList.Contains(PickupIndex.none))) {
                    return false;
                }
                return true;
            }
        }
    }
}
